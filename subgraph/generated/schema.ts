// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class Token extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Token entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Token", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Token | null {
    return changetype<Token | null>(store.get_in_block("Token", id));
  }

  static load(id: string): Token | null {
    return changetype<Token | null>(store.get("Token", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get currentScore(): BigInt {
    let value = this.get("currentScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currentScore(value: BigInt) {
    this.set("currentScore", Value.fromBigInt(value));
  }

  get currentVolume(): BigInt {
    let value = this.get("currentVolume");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currentVolume(value: BigInt) {
    this.set("currentVolume", Value.fromBigInt(value));
  }

  get lastUpdated(): BigInt {
    let value = this.get("lastUpdated");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdated(value: BigInt) {
    this.set("lastUpdated", Value.fromBigInt(value));
  }

  get isWhitelisted(): boolean {
    let value = this.get("isWhitelisted");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isWhitelisted(value: boolean) {
    this.set("isWhitelisted", Value.fromBoolean(value));
  }

  get updateCount(): BigInt {
    let value = this.get("updateCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set updateCount(value: BigInt) {
    this.set("updateCount", Value.fromBigInt(value));
  }

  get updates(): SentimentUpdateLoader {
    return new SentimentUpdateLoader(
      "Token",
      this.get("id")!.toString(),
      "updates",
    );
  }

  get dailyData(): DailySentimentLoader {
    return new DailySentimentLoader(
      "Token",
      this.get("id")!.toString(),
      "dailyData",
    );
  }

  get hourlyData(): HourlySentimentLoader {
    return new HourlySentimentLoader(
      "Token",
      this.get("id")!.toString(),
      "hourlyData",
    );
  }

  get circuitBreakerEvents(): CircuitBreakerEventLoader {
    return new CircuitBreakerEventLoader(
      "Token",
      this.get("id")!.toString(),
      "circuitBreakerEvents",
    );
  }
}

export class SentimentUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SentimentUpdate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SentimentUpdate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("SentimentUpdate", id.toString(), this);
    }
  }

  static loadInBlock(id: string): SentimentUpdate | null {
    return changetype<SentimentUpdate | null>(
      store.get_in_block("SentimentUpdate", id),
    );
  }

  static load(id: string): SentimentUpdate | null {
    return changetype<SentimentUpdate | null>(store.get("SentimentUpdate", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get score(): BigInt {
    let value = this.get("score");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set score(value: BigInt) {
    this.set("score", Value.fromBigInt(value));
  }

  get volume(): BigInt {
    let value = this.get("volume");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set volume(value: BigInt) {
    this.set("volume", Value.fromBigInt(value));
  }

  get sourceHash(): Bytes {
    let value = this.get("sourceHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sourceHash(value: Bytes) {
    this.set("sourceHash", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DailySentiment extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DailySentiment entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DailySentiment must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("DailySentiment", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DailySentiment | null {
    return changetype<DailySentiment | null>(
      store.get_in_block("DailySentiment", id),
    );
  }

  static load(id: string): DailySentiment | null {
    return changetype<DailySentiment | null>(store.get("DailySentiment", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get dayTimestamp(): BigInt {
    let value = this.get("dayTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set dayTimestamp(value: BigInt) {
    this.set("dayTimestamp", Value.fromBigInt(value));
  }

  get averageScore(): BigInt {
    let value = this.get("averageScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set averageScore(value: BigInt) {
    this.set("averageScore", Value.fromBigInt(value));
  }

  get highScore(): BigInt {
    let value = this.get("highScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set highScore(value: BigInt) {
    this.set("highScore", Value.fromBigInt(value));
  }

  get lowScore(): BigInt {
    let value = this.get("lowScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lowScore(value: BigInt) {
    this.set("lowScore", Value.fromBigInt(value));
  }

  get openScore(): BigInt {
    let value = this.get("openScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set openScore(value: BigInt) {
    this.set("openScore", Value.fromBigInt(value));
  }

  get closeScore(): BigInt {
    let value = this.get("closeScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set closeScore(value: BigInt) {
    this.set("closeScore", Value.fromBigInt(value));
  }

  get totalVolume(): BigInt {
    let value = this.get("totalVolume");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalVolume(value: BigInt) {
    this.set("totalVolume", Value.fromBigInt(value));
  }

  get updateCount(): BigInt {
    let value = this.get("updateCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set updateCount(value: BigInt) {
    this.set("updateCount", Value.fromBigInt(value));
  }
}

export class HourlySentiment extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HourlySentiment entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HourlySentiment must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("HourlySentiment", id.toString(), this);
    }
  }

  static loadInBlock(id: string): HourlySentiment | null {
    return changetype<HourlySentiment | null>(
      store.get_in_block("HourlySentiment", id),
    );
  }

  static load(id: string): HourlySentiment | null {
    return changetype<HourlySentiment | null>(store.get("HourlySentiment", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get hourTimestamp(): BigInt {
    let value = this.get("hourTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set hourTimestamp(value: BigInt) {
    this.set("hourTimestamp", Value.fromBigInt(value));
  }

  get averageScore(): BigInt {
    let value = this.get("averageScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set averageScore(value: BigInt) {
    this.set("averageScore", Value.fromBigInt(value));
  }

  get highScore(): BigInt {
    let value = this.get("highScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set highScore(value: BigInt) {
    this.set("highScore", Value.fromBigInt(value));
  }

  get lowScore(): BigInt {
    let value = this.get("lowScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lowScore(value: BigInt) {
    this.set("lowScore", Value.fromBigInt(value));
  }

  get totalVolume(): BigInt {
    let value = this.get("totalVolume");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalVolume(value: BigInt) {
    this.set("totalVolume", Value.fromBigInt(value));
  }

  get updateCount(): BigInt {
    let value = this.get("updateCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set updateCount(value: BigInt) {
    this.set("updateCount", Value.fromBigInt(value));
  }
}

export class CircuitBreakerEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CircuitBreakerEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CircuitBreakerEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("CircuitBreakerEvent", id.toString(), this);
    }
  }

  static loadInBlock(id: string): CircuitBreakerEvent | null {
    return changetype<CircuitBreakerEvent | null>(
      store.get_in_block("CircuitBreakerEvent", id),
    );
  }

  static load(id: string): CircuitBreakerEvent | null {
    return changetype<CircuitBreakerEvent | null>(
      store.get("CircuitBreakerEvent", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get previousScore(): BigInt {
    let value = this.get("previousScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set previousScore(value: BigInt) {
    this.set("previousScore", Value.fromBigInt(value));
  }

  get attemptedScore(): BigInt {
    let value = this.get("attemptedScore");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set attemptedScore(value: BigInt) {
    this.set("attemptedScore", Value.fromBigInt(value));
  }

  get maxChange(): BigInt {
    let value = this.get("maxChange");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set maxChange(value: BigInt) {
    this.set("maxChange", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Operator extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Operator entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Operator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Operator", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Operator | null {
    return changetype<Operator | null>(store.get_in_block("Operator", id));
  }

  static load(id: string): Operator | null {
    return changetype<Operator | null>(store.get("Operator", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }

  get addedAt(): BigInt {
    let value = this.get("addedAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set addedAt(value: BigInt) {
    this.set("addedAt", Value.fromBigInt(value));
  }

  get removedAt(): BigInt | null {
    let value = this.get("removedAt");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set removedAt(value: BigInt | null) {
    if (!value) {
      this.unset("removedAt");
    } else {
      this.set("removedAt", Value.fromBigInt(<BigInt>value));
    }
  }

  get updateCount(): BigInt {
    let value = this.get("updateCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set updateCount(value: BigInt) {
    this.set("updateCount", Value.fromBigInt(value));
  }
}

export class OracleStats extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleStats entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OracleStats must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("OracleStats", id.toString(), this);
    }
  }

  static loadInBlock(id: string): OracleStats | null {
    return changetype<OracleStats | null>(
      store.get_in_block("OracleStats", id),
    );
  }

  static load(id: string): OracleStats | null {
    return changetype<OracleStats | null>(store.get("OracleStats", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalTokens(): BigInt {
    let value = this.get("totalTokens");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalTokens(value: BigInt) {
    this.set("totalTokens", Value.fromBigInt(value));
  }

  get activeTokens(): BigInt {
    let value = this.get("activeTokens");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set activeTokens(value: BigInt) {
    this.set("activeTokens", Value.fromBigInt(value));
  }

  get totalUpdates(): BigInt {
    let value = this.get("totalUpdates");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalUpdates(value: BigInt) {
    this.set("totalUpdates", Value.fromBigInt(value));
  }

  get isPaused(): boolean {
    let value = this.get("isPaused");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isPaused(value: boolean) {
    this.set("isPaused", Value.fromBoolean(value));
  }

  get lastUpdate(): BigInt {
    let value = this.get("lastUpdate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdate(value: BigInt) {
    this.set("lastUpdate", Value.fromBigInt(value));
  }

  get circuitBreakerTriggers(): BigInt {
    let value = this.get("circuitBreakerTriggers");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set circuitBreakerTriggers(value: BigInt) {
    this.set("circuitBreakerTriggers", Value.fromBigInt(value));
  }
}

export class SentimentUpdateLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): SentimentUpdate[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<SentimentUpdate[]>(value);
  }
}

export class DailySentimentLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DailySentiment[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DailySentiment[]>(value);
  }
}

export class HourlySentimentLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): HourlySentiment[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<HourlySentiment[]>(value);
  }
}

export class CircuitBreakerEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): CircuitBreakerEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<CircuitBreakerEvent[]>(value);
  }
}
